# ملخص شامل للمحاضرات وأنماط التصميم وخدمات الويب

## مقدمة: متطلبات الشرح وتصميم الموقع

بناءً على التوجيهات المقدمة، يهدف هذا الملخص إلى تقديم شروحات تفصيلية للمحاضرات المرفقة، مع الالتزام بمعايير محددة لضمان الوضوح والدقة وسهولة الفهم. كما يتضمن الملخص متطلبات تصميم موقع ويب لعرض هذه المحاضرات بشكل فعال.

### معايير الشروحات:

*   **تنسيقات الملفات المدعومة**: يجب أن تدعم الصور المضمنة في ملفات PDF/PPTX وتحتفظ بالتنسيق الأصلي. يجب التعامل مع النصوص البرمجية في DOCX (مثل الكود) ككتل منفصلة. سيتم تجاهل الملفات التي تحتوي على صفحات فارغة بنسبة تزيد عن 40% من المحتوى.
*   **تفصيل الشروحات**: سيتم تقسيم المحتوى إلى 3-5 أقسام تبعًا للمواضيع. سيتم استخدام علامات التبويب (Tabs) للمقارنات المعقدة. سيتم إضافة 2-3 أمثلة واقعية لكل مفهوم (أمثلة صناعية غير موجودة في المحاضرة). سيتم تصميم جداول مقارنة للأفكار المرتبطة.
*   **هيكل ملفات الشرح**: ستكون الملفات النصية بتنسيق Markdown (.md) مع علامات HTML قياسية. سيتم إضافة توقيع نصي في نهاية كل ملف: `<!-- شرح مُعد بواسطة AI بناءً على المحاضرة: [رقم المحاضرة] -->`.

### متطلبات تصميم الموقع:

*   **التقنيات المبنية على الأدلة**: استخدام CSS Grid + Flexbox مع إطار عمل خفيف (مثل Tailwind CSS). تنفيذ تصميم متجاوب بمعايير W3C للتوافق مع شاشات من 320px إلى 1440px. تضمين مكونات تفاعلية مثل نظام تصفية المحاضرات عبر البحث الفوري، زر "العودة إلى الأعلى" مع تأثير تمرير ناعم، ونظام إشارات مرجعية (Bookmark) للنقاط المهمة. تضمين أتمتة لتحسين الصور (مثل استخدام WebP بدل JPEG).
*   **معايير الأداء**: وقت تحميل الصفحة الرئيسية ≤ 1.5 ثانية (على اتصال 4G مزيف). درجة الأداء في Lighthouse ≥ 90 لجميع المقاييس (التحميل، الاستقرار، التفاعل). ضمان توافق كامل مع Safari (iOS) ≥ iOS 14، Chrome ≥ v90، Firefox ≥ v88. تحسين محركات البحث (SEO) عبر Tags معبأة تلقائيًا من الكلمات المفتاحية وتنظيم السمات الهيكلية (schema) لعرض المحاضرات في نتائج البحث.
*   **التفاصيل البصرية**: استخدام خطوط Inter للأحجام الصغيرة والمتوسطة و Playfair Display للعناوين الرئيسية فقط. نظام الألوان: #1A1A1A (أسود عميق)، #F5F5F5 (رمادي فاتح)، #FFD700 (ذهبي). التدرجات: أفقية أو عمودية بزاوية تلقائية. تأثيرات بصرية: hover effects على البطاقات بتأثير تمويج (ripple effect) وظهور تدريجي (fade-in) للعناصر عند التمرير (Scroll-triggered animation).
*   **الميزات التفاعلية**: شاشة التحميل: تظهر دومًا حتى تحميل 80% من موارد الصفحة. شريط التقدم: يتحرك أفقيًا بناءً على نسبة القراءة. تفاعل الماوس: تأثير "عدسة التكبير" عند Hover على الصور وتغيير خلفية الصفحة بلون عشوائي من لوحة الألوان عند النقر الطويل.
*   **التوثيق**: دليل استخدام الموقع (ملف Readme.md) يتضمن طريقة تنفيذ تعديلات على المحتوى وشرح أكواد JavaScript المستخدمة في الميزات التفاعلية. دليل النشر يتضمن تعليمات مفصلة لنشر الموقع عبر Netlify (مع دعم CI/CD لمشروعات GitHub) ونموذج ملف `.gitignore` للمشاريع.
*   **معايير الجودة وتجربة المستخدم (UX)**: اختبار الوصول (Accessibility) يتضمن دعم قارئات الشاشة عبر ARIA Labels والتأكد من تباين الألوان بحد أدنى WCAG 2.1 AA. تجربة المستخدم تتضمن زمن استجابة النقرات ≤ 100 مللي ثانية ودعم التنقل عبر لوحة المفاتيح (Keyboard navigation) لجميع الميزات.

---






# نمط Decorator

## الدور (Role)

نمط Decorator يوفر طريقة لإضافة حالة وسلوك جديدين إلى كائن ديناميكيًا. النقطة الأساسية في تطبيق هذا النمط هي أن الـ Decorators يرثون الفئة الأصلية ويحتوون على نسخة منها.

## التوضيح (Illustration)

يأخذ نمط Decorator كائنًا موجودًا ويضيف إليه. على سبيل المثال، هناك طرق عديدة لإضافة تأثيرات إلى صورة، مثل وضع إطار حولها أو تحديد علامات (tags) تتعلق بالمحتوى. يمكن عرض هذه الإضافات فوق الصورة.

## التصميم (Design)

اللاعبون الأساسيون في هذا النمط هم:

*   **Component**: فئة أصلية من الكائنات التي يمكن إضافة عمليات إليها أو تعديلها.
*   **Operation**: عملية في كائنات IComponent يمكن استبدالها.
*   **IComponent**: الواجهة التي تحدد فئات الكائنات التي يمكن تزيينها (Component هي إحدى هذه الفئات).
*   **Decorator**: فئة تتوافق مع واجهة IComponent وتضيف حالة و/أو سلوكًا.

تتضمن فئة Decorator نوعين من العلاقات مع واجهة IComponent:

*   **علاقة "Is-a"**: يظهر بسهم منقط من Decorator إلى IComponent، مما يشير إلى أن Decorator يحقق واجهة IComponent. هذا يعني أنه يمكن استخدام كائنات Decorator حيثما يتوقع وجود كائنات IComponent.
*   **علاقة "Has-a"**: يظهر بماس مفتوح على Decorator، مرتبط بـ IComponent. يشير هذا إلى أن Decorator يقوم بإنشاء نسخة واحدة أو أكثر من كائنات IComponent، وأن الكائنات المزينة يمكن أن تستمر بعد الكائنات الأصلية. يستخدم Decorator السمة `component` (من نوع IComponent) لاستدعاء أي عملية استبدال قد يرغب في تجاوزها. هذه هي الطريقة التي يحقق بها نمط Decorator هدفه.

## تطبيقات متعددة (Multiple Applications)

*   **مكونات متعددة**: يمكن تزيين مكونات مختلفة تتوافق مع الواجهة. على سبيل المثال، يمكن أن تكون لدينا فئة ترسم أشخاصًا، منازل، سفن، وما إلى ذلك من أشكال وخطوط بسيطة. يمكن أيضًا وضع علامات عليها. لهذا السبب، تعد واجهة IComponent مهمة، حتى لو لم تحتوي على أي عمليات.
*   **Decorators متعددة**: يمكننا إنشاء أنواع أخرى من الـ Decorators، مثل Decorators الحدود أو حتى Decorators التي تجعل الصورة غير مرئية. بغض النظر عن ماهية الـ Decorators، يحتوي كل منها على كائن مكون، والذي قد يكون هو نفسه Decorator، مما يؤدي إلى سلسلة من التغييرات.
*   **عمليات متعددة**: يركز التوضيح على الرسم كعملية رئيسية للصور والزخارف. أمثلة أخرى ستوفر المزيد من العمليات الاختيارية. بعض هذه العمليات ستكون جزءًا من المكون الأصلي وواجهته، بينما سيتم إضافة بعضها كسلوكيات في Decorators معينة فقط. يمكن للعميل استدعاء أي من العمليات بشكل فردي على أي من المكونات (المزينة أو غير المزينة) التي لديه حق الوصول إليها.

## التنفيذ (Implementation)

الميزة الرئيسية لنمط Decorator هي أنه لا يعتمد على الوراثة لتوسيع السلوك. إذا كان على فئة `Tag` أن ترث من فئة `Photo` لإضافة طريقة أو طريقتين، فإن `Tags` ستحمل كل ما يتعلق بـ `Photos` معها، مما يجعلها كائنات ثقيلة جدًا. بدلاً من ذلك، فإن جعل فئة `Tag` تنفذ واجهة `Photo` ثم تضيف سلوكًا يحافظ على كائنات `Tag` خفيفة الوزن. يمكنها:

*   تنفيذ أي طرق في الواجهة، وتغيير السلوك الأولي للمكون.
*   إضافة أي حالة وسلوك جديدين.
*   الوصول إلى أي أعضاء عامين عبر الكائن الذي تم تمريره عند الإنشاء.

## مخطط UML

![مخطط UML لنمط Decorator](/home/ubuntu/explanations/assets/decorator_uml.png)

---



# نمط Proxy

## الدور (Role)

يدعم نمط Proxy الكائنات التي تتحكم في إنشاء الكائنات الأخرى والوصول إليها. غالبًا ما يكون الوكيل (Proxy) كائنًا صغيرًا (عامًا) يحل محل كائن أكثر تعقيدًا (خاصًا) يتم تنشيطه بمجرد وضوح ظروف معينة.

## التوضيح (Illustration)

ظاهرة رئيسية في العالم اليوم هي تزايد شعبية أنظمة الشبكات المجتمعية. يمكن استخدام نمط الوكيل في هذه الأنظمة للتحكم في الوصول إلى الموارد أو تأخير إنشاء الكائنات الثقيلة.

## التصميم (Design)

اللاعبون في هذا النمط هم:

1.  **ISubject**: واجهة مشتركة للمواضيع (Subjects) والوكلاء (Proxies) تمكنهم من الاستخدام بالتبادل.
2.  **Subject**: الفئة التي يمثلها الوكيل.
3.  **Proxy**: فئة تقوم بإنشاء، والتحكم في، وتحسين، وتوثيق الوصول إلى Subject.
4.  **Request**: عملية على Subject يتم توجيهها عبر وكيل.

تنفذ الفئة المركزية، Proxy، واجهة ISubject. يمكن للعميل استخدام ISubject لتجريد نفسه من الوكلاء. يحتفظ كل كائن Proxy بمرجع إلى Subject، حيث يحدث الإجراء بالفعل. يقوم الوكيل بالعمل الأمامي. يمكن تعزيز قيمته بجعل Subject فئة خاصة بحيث لا يمكن للعميل الوصول إلى Subject إلا عبر الوكيل.

## أنواع الوكلاء (Types of Proxies)

هناك عدة أنواع من الوكلاء:

1.  **الوكلاء الافتراضيون (Virtual proxies)**: يسلمون إنشاء كائن إلى كائن آخر (مفيد إذا كانت عملية الإنشاء قد تكون بطيئة أو قد تثبت أنها غير ضرورية).
2.  **وكلاء المصادقة (Authentication proxies)**: يتحققون من صحة أذونات الوصول لطلب ما.
3.  **الوكلاء عن بعد (Remote proxies)**: يقومون بترميز الطلبات وإرسالها عبر الشبكة.
4.  **الوكلاء الذكيون (Smart proxies)**: يضيفون إلى الطلبات أو يغيرونها قبل إرسالها.

ضمن نطاق نظام الشبكات الاجتماعية المذكور سابقًا، تتوافق هذه الأنواع على النحو التالي:

*   تأخير إنشاء بيئة غنية (وكيل افتراضي).
*   تسجيل دخول المستخدمين (وكيل مصادقة).
*   إرسال الطلبات عبر الشبكة (وكيل عن بعد).
*   تنفيذ الإجراءات على كتب الأصدقاء (وكيل ذكي).

## التنفيذ (Implementation)

الصفوف والكائنات المشاركة في هذا النمط هي:

*   **Proxy (MathProxy)**:
    *   يحتفظ بمرجع يسمح للوكيل بالوصول إلى الموضوع الحقيقي. قد يشير الوكيل إلى Subject إذا كانت واجهات RealSubject و Subject هي نفسها.
    *   يوفر واجهة مطابقة لواجهة Subject بحيث يمكن استبدال الوكيل بالموضوع الحقيقي.
    *   يتحكم في الوصول إلى الموضوع الحقيقي وقد يكون مسؤولاً عن إنشائه وحذفه.
    *   تعتمد المسؤوليات الأخرى على نوع الوكيل:
        *   **الوكلاء عن بعد (remote proxies)**: مسؤولون عن ترميز الطلب وحججه وإرسال الطلب المرمز إلى الموضوع الحقيقي في مساحة عنوان مختلفة.
        *   **الوكلاء الافتراضيون (virtual proxies)**: قد يقومون بتخزين معلومات إضافية حول الموضوع الحقيقي حتى يتمكنوا من تأجيل الوصول إليه. على سبيل المثال، يقوم ImageProxy من Motivation بتخزين مدى الصور الحقيقية مؤقتًا.
        *   **وكلاء الحماية (protection proxies)**: يتحققون من أن المتصل لديه أذونات الوصول المطلوبة لتنفيذ طلب.
*   **Subject (IMath)**: يحدد الواجهة المشتركة لـ RealSubject و Proxy بحيث يمكن استخدام Proxy في أي مكان يتوقع فيه RealSubject.
*   **RealSubject (Math)**: يحدد الكائن الحقيقي الذي يمثله الوكيل.

## مخطط UML

![مخطط UML لنمط Proxy](/home/ubuntu/explanations/assets/proxy_uml.png)

---



# نمط Strategy

## الدور (Role)

نمط Strategy يحدد مجموعة من الخوارزميات التي يمكن استخدامها بالتبادل. يسمح نمط Strategy بتغيير الخوارزمية بشكل مستقل عن العملاء الذين يستخدمونها. يلتقط التجريد في واجهة، ويدفن تفاصيل التنفيذ في الفئات المشتقة.

## التوضيح (Illustration)

تعتبر وسائل النقل إلى المطار مثالاً على نمط Strategy. القيادة بالسيارة الخاصة، أو ركوب سيارة أجرة، أو حافلة المطار، أو حافلة المدينة، أو خدمة الليموزين. أي من هذه الوسائل ستوصل المسافر إلى المطار، ويمكن استخدامها بالتبادل. يجب على المسافر اختيار الاستراتيجية بناءً على المفاضلات بين التكلفة والراحة والوقت.

## المشكلة (Problem)

إحدى الاستراتيجيات السائدة في تصميم الكائنات الموجهة هي "مبدأ الفتح والإغلاق"، حيث يكون الكيان البرمجي مفتوحًا للتوسع ومغلقًا للتعديل. يوضح النمط كيفية تحقيق ذلك بشكل روتيني:

*   تغليف تفاصيل الواجهة في فئة أساسية، ودفن تفاصيل التنفيذ في الفئات المشتقة.
*   يمكن للعملاء بعد ذلك ربط أنفسهم بواجهة، ولا يضطرون إلى تجربة الاضطراب المرتبط بالتغيير:
    *   لا يوجد تأثير عند تغيير عدد الفئات المشتقة.
    *   لا يوجد تأثير عند تغيير تنفيذ فئة مشتقة.

## التصميم (Design)

يمكن أن يمثل كيان الواجهة إما فئة أساسية مجردة، أو توقعات توقيع الطريقة من قبل العميل. في الحالة الأولى، يمثل التسلسل الهرمي للوراثة تعدد الأشكال الديناميكي. في الحالة الأخيرة، يمثل كيان الواجهة رمز القالب في العميل ويمثل التسلسل الهرمي للوراثة تعدد الأشكال الثابت.

## المكونات (Components)

*   **Strategy**: واجهة أو فئة مجردة تحدد واجهة مشتركة لجميع الخوارزميات المدعومة.
*   **ConcreteStrategy**: فئات تنفذ واجهة Strategy وتوفر تنفيذًا محددًا للخوارزمية.
*   **Context**: الفئة التي تحتوي على مرجع إلى كائن Strategy وتتفاعل معه. يمكن لـ Context تغيير Strategy في وقت التشغيل.

## مخطط UML

![مخطط UML لنمط Strategy](/home/ubuntu/explanations/assets/strategy_uml.png)

---



# نمط State

## الدور (Role)

يمكن اعتبار نمط State نسخة ديناميكية من نمط Strategy. يسمح للكائن بتغيير سلوكه ديناميكيًا وفقًا لحالته الداخلية. عندما تتغير الحالة داخل الكائن، يمكنه تغيير سلوكه عن طريق التبديل إلى مجموعة مختلفة من العمليات. يتم تحقيق التغيير عن طريق تغيير متغير الكائن لفئته الفرعية، ضمن تسلسل هرمي.

## التصميم (Design)

## المكونات (Components)

1.  **Context**: فئة تحتفظ بنسخة من State تحدد السياق الحالي والواجهة ذات الأهمية للعملاء.
2.  **IState**: تحدد واجهة لحالة معينة من Context.
3.  **StateA و StateB**: فئات تنفذ السلوك المرتبط بحالة Context.

## مخطط UML

![مخطط UML لنمط State](/home/ubuntu/explanations/assets/state_uml.png)

---



# نمط Facade

## الدور (Role)

يوفر نمط Facade واجهة موحدة لمجموعة من الواجهات في نظام فرعي. يحدد Facade واجهة ذات مستوى أعلى تجعل استخدام النظام الفرعي أسهل.

## المشكلة (Problem)

قد تحتاج إلى استخدام مجموعة فرعية فقط من نظام معقد، أو تحتاج إلى التفاعل مع النظام بطريقة معينة. في هذه الحالات، يمكن أن يصبح التعامل مع العديد من الكائنات والواجهات أمرًا صعبًا.

## الحل (Solution)

يقدم Facade واجهة جديدة لعميل النظام الحالي لاستخدامها. هذه الواجهة المتخصصة تجعل استخدام النظام الفرعي المطلوب أسهل.

## المشاركون والمتعاونون (Participants and Collaborators)

*   **Facade (Mortgage Application)**:
    *   يعرف أي فئات النظام الفرعي مسؤولة عن طلب ما.
    *   يفوض طلبات العميل إلى كائنات النظام الفرعي المناسبة.
*   **Subsystem classes (Bank, Credit, Loan)**:
    *   تنفذ وظائف النظام الفرعي.
    *   تتعامل مع العمل المخصص من قبل كائن Facade.
    *   ليس لديها معرفة بالواجهة الأمامية ولا تحتفظ بأي مرجع إليها.

## الميزات (Features)

*   **الهدف (Intent)**: تبسيط كيفية استخدام نظام موجود. تحتاج إلى تحديد واجهتك الخاصة.
*   **المشكلة (Problem)**: تحتاج إلى استخدام مجموعة فرعية فقط من نظام معقد. أو تحتاج إلى التفاعل مع النظام بطريقة معينة.
*   **الحل (Solution)**: يقدم Facade واجهة جديدة لعميل النظام الحالي لاستخدامها.
*   **المشاركون والمتعاونون (Participants and Collaborators)**: يقدم واجهة متخصصة للعميل تجعل استخدامه أسهل.
*   **النتائج (Consequences)**: يبسط Facade استخدام النظام الفرعي المطلوب. ومع ذلك، نظرًا لأن Facade ليس كاملاً، فقد لا تكون بعض الوظائف متاحة للعميل.
*   **التنفيذ (Implementation)**:
    *   تحديد فئة (أو فئات) جديدة تحتوي على الواجهة المطلوبة.
    *   جعل هذه الفئة الجديدة تستخدم النظام الحالي.

## استخدام نمط Facade (Using Facade Pattern)

يمكن استخدام Facades ليس فقط لإنشاء واجهة أبسط من حيث استدعاءات الأساليب، بل يقللون أيضًا من عدد الكائنات التي يجب على كائن العميل التعامل معها. على سبيل المثال، إذا كان لديك كائن عميل يجب أن يتعامل مع قواعد البيانات والنماذج والعناصر، فقد يكون من الأسهل إنشاء Facade لقاعدة البيانات يمكن للعميل الاستعلام عنها.

## مخطط UML

![مخطط UML لنمط Facade](/home/ubuntu/explanations/assets/facade_uml.png)

---



# نمط Adapter

## الدور (Role)

نمط Adapter هو نمط متعدد الاستخدامات يربط بين أنواع لم يتم تصميمها للعمل مع بعضها البعض. إنه أحد تلك الأنماط المفيدة عند التعامل مع التعليمات البرمجية القديمة - أي التعليمات البرمجية التي تمت كتابتها منذ فترة ولم يكن من الممكن الوصول إليها. يتيح هذا النمط للنظام استخدام الفئات التي لا تتطابق واجهاتها تمامًا مع متطلباته. وهو مفيد بشكل خاص للتعليمات البرمجية الجاهزة، ومجموعات الأدوات، والمكتبات. يمكن للمحول (Adapter) قبول المكالمات من التطبيق وتحويلها إلى مكالمات على أساليب مجموعة الأدوات.

## التوضيح (Illustration)

من عام 1996 إلى عام 2006، عملت أجهزة كمبيوتر Apple Macintosh بمعالج PowerPC. كان نظام التشغيل هو Mac OS X. ولكن في أبريل 2006، بدأت Apple في إصدار جميع أجهزة كمبيوتر Apple الجديدة - iMacs و Minis و MacBooks - بمعالجات Intel Core Duo. تمت إعادة كتابة Mac OS X لاستهداف المعالج الجديد، وكان مستخدمو أجهزة الكمبيوتر الجديدة يصلون في الغالب إلى برامج Intel الموجودة عبر أنظمة تشغيل أخرى، مثل Linux و Windows. هذا مثال على كيفية استخدام نمط Adapter لجعل الأنظمة القديمة متوافقة مع التقنيات الجديدة.

## التصميم (Design)

*   **ITarget**: الواجهة التي يريد العميل استخدامها.
*   **Adaptee**: تطبيق يحتاج إلى التكيف.
*   **Adapter**: الفئة التي تنفذ واجهة ITarget من حيث Adaptee.
*   **Request**: عملية يريدها العميل.
*   **SpecificRequest**: تنفيذ وظيفة Request في Adaptee.

## التنفيذ (Implementation)

يتضمن نمط Adapter تغييرات في المدخلات/المخرجات. على سبيل المثال، سيكون للبرامج المكتوبة في الثمانينيات واجهات مستخدم مختلفة جدًا عن تلك المكتوبة في العقد الأول من القرن الحادي والعشرين. إن القدرة على تكييف أجزاء النظام هذه مع مرافق الأجهزة الجديدة ستكون أكثر فعالية من حيث التكلفة من إعادة كتابتها.

## مخطط UML

![مخطط UML لنمط Adapter](/home/ubuntu/explanations/assets/adapter_uml.png)

---



# نمط Prototype

## الدور (Role)

نمط Prototype هو نمط تصميم يستخدم لإنشاء نسخة من فئة عن طريق نسخ، أو استنساخ، خصائص كائن موجود. الكائن الجديد هو نسخة طبق الأصل من النموذج الأولي ولكنه يسمح بالتعديل دون تغيير الأصل. هذا نمط إنشائي لأنه يستخدم للتحكم في إنشاء الفئات وتوليد الكائنات. يستخدم النمط لإنشاء كائن جديد عن طريق نسخ جميع خصائص كائن موجود، مما يؤدي إلى إنشاء نسخة مستقلة.

## المكونات (Components)

اللاعبون الرئيسيون في النمط هم:

*   **IPrototype**: يحدد الواجهة التي تقول إن النماذج الأولية يجب أن تكون قابلة للاستنساخ.
*   **Prototype**: فئة ذات قدرات استنساخ.
*   **PrototypeManager**: يحتفظ بقائمة من أنواع الاستنساخ ومفاتيحها.
*   **Client**: يضيف النماذج الأولية إلى القائمة ويطلب الاستنساخ.

## مخطط UML

![مخطط UML لنمط Prototype](/home/ubuntu/explanations/assets/prototype_uml.png)

---



# خدمات الويب (Web Services)

## مقدمة إلى خدمات الويب

خدمة الويب هي نظام برمجي مصمم لدعم التفاعل القابل للتشغيل البيني بين التطبيقات المختلفة عبر الشبكة مثل الإنترنت أو شبكة داخلية خاصة. تستخدم بروتوكولات اتصال موحدة للسماح لتطبيقين أو أكثر — قد يكونان مكتوبين بلغات برمجة مختلفة ويعملان على أنظمة تشغيل مختلفة — بالتواصل وتبادل البيانات بسلاسة.

يتم الاتصال بين العميل وخدمة الويب غالبًا باستخدام:

*   **لغة الترميز القابلة للتوسيع (XML)** عند اتباع نمط بروتوكول الوصول البسيط للكائنات (SOAP).
*   **تنسيق كائن جافا سكريبت (JSON)** أو XML عند اتباع نمط نقل الحالة التمثيلية (REST).

## الغرض من استخدام خدمات الويب

تمكن خدمات الويب التشغيل البيني. على سبيل المثال:

*   يمكن لبرنامج مكتوب بلغة Python التواصل مع خدمة مكتوبة بلغة Java.
*   يمكن لعميل يعمل بنظام Windows طلب بيانات من خدمة تعمل على خادم Linux.

## ميزات خدمات الويب

*   **مستقلة عن اللغة ونظام التشغيل**: يمكن بناء التطبيقات بأي لغة ونشرها على أي نظام تشغيل.
*   **تستخدم معايير مفتوحة**: على سبيل المثال، بروتوكول نقل النص التشعبي (HTTP)، XML، JSON، SOAP، ولغة وصف خدمات الويب (WSDL).
*   **وصف ذاتي**: تصف الخدمات نفسها باستخدام تنسيقات قائمة على XML مثل WSDL أو تنسيقات قائمة على JSON مثل مواصفات OpenAPI.
*   **قابلة للاكتشاف**: يمكن تسجيل الخدمات والعثور عليها باستخدام سجلات مثل Universal Description, Discovery, and Integration (UDDI).

## لماذا نستخدم خدمات الويب؟

توفر خدمات الويب العديد من الفوائد الهامة:

*   **كشف الوظائف الموجودة**: تسمح للتطبيقات القديمة أو الأنظمة الأساسية بأن تكون قابلة للوصول إلى أنظمة أخرى عبر الشبكة دون إعادة كتابة التعليمات البرمجية.
*   **التشغيل البيني بين الأنظمة غير المتجانسة**: ربط التطبيقات المبنية بلغات برمجة مختلفة والمنشورة على منصات مختلفة.
*   **بروتوكولات الاتصال الموحدة**: استخدام معايير معترف بها في الصناعة مثل SOAP عبر HTTP، REST عبر HTTP، و XML لهيكلة البيانات.
*   **اتصال منخفض التكلفة**: الاستفادة من البنية التحتية للإنترنت الموجودة بدلاً من حلول الاتصال الاحتكارية باهظة الثمن.
*   **هندسة معمارية مفككة الارتباط**: يمكن للمستهلك (مستهلك الخدمة) والمزود (مزود الخدمة) التغيير بشكل مستقل طالما أنهما يحترمان الواجهة المتفق عليها.

## أنواع خدمات الويب

*   **بروتوكول الوصول البسيط للكائنات (SOAP)**:
    *   بروتوكول رسائل قائم على XML.
    *   يعمل عبر بروتوكولات نقل متعددة مثل HTTP، بروتوكول نقل البريد البسيط (SMTP)، وبروتوكول نقل الملفات (FTP).
    *   يتطلب WSDL لوصف العمليات المتاحة وتنسيقات الرسائل.
*   **نقل الحالة التمثيلية (REST)**:
    *   نمط معماري يستخدم أساليب HTTP (GET, POST, PUT, DELETE) للعمل على الموارد.
    *   يعيد JSON بشكل متكرر ولكنه يمكن أيضًا أن يعيد XML أو تنسيقات أخرى.
    *   أسهل في الاستخدام وأسرع بشكل عام من SOAP.
*   **لغة الترميز القابلة للتوسيع - استدعاء الإجراء عن بعد (XML-RPC)**:
    *   آلية أقدم قائمة على XML لاستدعاءات الإجراءات عن بعد.
    *   تقوم بترميز استدعاءات الأساليب والاستجابات في XML وتنقلها عبر HTTP.

## المكونات الأساسية لخدمات الويب

*   **SOAP**: بروتوكول رسائل يحدد بنية XML للطلبات والاستجابات.
*   **لغة وصف خدمات الويب (WSDL)**: لغة قائمة على XML تصف واجهة الخدمة، والأساليب المتاحة، والمعلمات، وموقع الشبكة.
*   **Universal Description, Discovery, and Integration (UDDI)**: نظام سجل حيث يمكن نشر خدمات الويب واكتشافها.
*   **طبقة النقل (Transport Layer)**: بروتوكولات مثل HTTP، SMTP، و FTP المستخدمة لنقل الرسائل.

## كيف تعمل خدمات الويب - التدفق العام

1.  **تطبيق العميل يرسل طلبًا**:
    *   في SOAP: يرسل رسالة XML ملفوفة بتنسيق SOAP.
    *   في REST: يرسل طلب HTTP مع البيانات بتنسيق JSON أو XML.
2.  **الخادم يعالج الطلب**: تنفذ الخدمة الأسلوب أو العملية المقابلة.
3.  **الخادم يرسل استجابة**:
    *   SOAP: استجابة بتنسيق XML.
    *   REST: استجابة بتنسيق JSON أو XML.

## مقارنة: SOAP مقابل REST في Python

| الميزة          | SOAP (zeep)                      | REST (requests)                 |
| :-------------- | :------------------------------- | :------------------------------ |
| تنسيق البيانات  | XML فقط                          | JSON أو XML                     |
| دعم البروتوكول  | HTTP, SMTP, FTP | HTTP                            |
| التعقيد         | عالٍ (مخططات XML صارمة)         | منخفض (تنسيقات مرنة)           |
| السرعة          | أبطأ (عبء إضافي أكبر)            | أسرع (أقل تفصيلاً)              |
| الأفضل لـ       | أنظمة الشركات والأنظمة المالية | تطبيقات الويب والجوال            |

## تدفق عمل خدمات الويب

![تدفق عمل خدمات الويب](/home/ubuntu/explanations/assets/web_services_flow.png)

---


